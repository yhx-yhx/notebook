import{_ as e,o as a,c as l,V as i}from"./chunks/framework.b7ceec1d.js";const f=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"pages/Notes/2023/learn_vue3_coderwhy.md"}'),o={name:"pages/Notes/2023/learn_vue3_coderwhy.md"},t=i('<h2 id="一般指令" tabindex="-1">一般指令 <a class="header-anchor" href="#一般指令" aria-label="Permalink to &quot;一般指令&quot;">​</a></h2><h3 id="v-once" tabindex="-1">v-once <a class="header-anchor" href="#v-once" aria-label="Permalink to &quot;v-once&quot;">​</a></h3><ul><li>只渲染 一次</li><li>当 有子集时 子集也是仅仅渲染 一次</li><li>该指令可以被用作 性能优化 “没遇见过场景”</li></ul><h3 id="v-pre" tabindex="-1">v-pre <a class="header-anchor" href="#v-pre" aria-label="Permalink to &quot;v-pre&quot;">​</a></h3><ul><li>相当于 原生的 pre 标签</li><li>跳过编译 直接将被包裹的模板 渲染到页面上</li></ul><h3 id="v-cloak" tabindex="-1">v-cloak <a class="header-anchor" href="#v-cloak" aria-label="Permalink to &quot;v-cloak&quot;">​</a></h3><ul><li>主要是 为了避免 模板语法 ssr 下的渲染问题 大括号语法 尚未编译渲染在页面上</li><li>原理 再dom 上架了 <code>class {display：none}</code></li></ul><h3 id="v-bind" tabindex="-1">v-bind <a class="header-anchor" href="#v-bind" aria-label="Permalink to &quot;v-bind&quot;">​</a></h3><ul><li>简写 :</li><li>动态绑定属性 ： <code>:[name]=&quot;value&quot; 属性名称以及 值 都在 data中取值</code></li></ul><h2 id="v-on" tabindex="-1">v-on <a class="header-anchor" href="#v-on" aria-label="Permalink to &quot;v-on&quot;">​</a></h2><ul><li><p>简称 @</p></li><li><p>修饰符 .</p></li></ul><blockquote><ul><li><p>stop 阻止事件冒泡 调用 event.stopPropagation() 事件冒泡 子里向外</p></li><li><p>prevent 阻止默认事件 调用 event.preventDefault()</p></li><li><p>capture 添加事件监听器 使用 capture 事件捕获 在外向里 （当然也可以理解 为 捕获的优先级 是高于 冒泡的）</p></li><li><p>self 当触发 绑定元素 才会触发 事件</p></li><li><p>{keyAlias} 仅当事件 从特定的 建触发 才会被触发回调 例<code>@click.enter=&quot;test&quot;</code> 当键盘按下 enter 会被触发</p></li><li><p>once 只触发一次回调</p></li><li><p>left 只当鼠标 左键可以触发回调</p></li><li><p>right 只当鼠标右键 可以触发回调</p></li><li><p>middle 只当触发 鼠标中间键 时 触发回调</p></li><li><p>passive 一般用于 触摸事件的监听器 用来改善 移动端的滚屏性能</p></li></ul></blockquote><h3 id="v-if-v-show" tabindex="-1">v-if v-show <a class="header-anchor" href="#v-if-v-show" aria-label="Permalink to &quot;v-if  v-show&quot;">​</a></h3><ul><li>区别 v-if频繁切换 开销比较大 频繁切换 场景一般 用 v-show来实现 v-show 不能写在 template上</li><li>v-show diplay none</li><li>v-if是将 元素内容直接销毁的</li></ul><h3 id="v-for" tabindex="-1">v-for <a class="header-anchor" href="#v-for" aria-label="Permalink to &quot;v-for&quot;">​</a></h3><ul><li><p>支持对象</p></li><li><p><code>v-for =&quot;(value,key,index) in {name:&#39;uuuu&#39;,age=&#39;23&#39;}&quot;</code></p></li><li><p>渲染结果 <code>uuuu name 0;23 age 1</code></p></li></ul><h3 id="数组检测更新" tabindex="-1">数组检测更新 <a class="header-anchor" href="#数组检测更新" aria-label="Permalink to &quot;数组检测更新&quot;">​</a></h3><p>简而言之 就是 vue 将 pop push unshift shift sort reverse splice 做了处理（重写）</p><p>对于 filter concat slice 生成新的 数组 不改变原来数组</p><h3 id="diff算法" tabindex="-1">diff算法 <a class="header-anchor" href="#diff算法" aria-label="Permalink to &quot;diff算法&quot;">​</a></h3><h3 id="computed" tabindex="-1">computed <a class="header-anchor" href="#computed" aria-label="Permalink to &quot;computed&quot;">​</a></h3><ul><li>与methods 最大的区别在于 缓存 computed 是有缓存，当数据源不变的情况下 computed getter 不会再次被触发</li><li>getter setter 改变getter 数据源 达到改变 computed 的意图</li></ul>',22),r=[t];function n(c,d,u,h,s,p){return a(),l("div",null,r)}const m=e(o,[["render",n]]);export{f as __pageData,m as default};
