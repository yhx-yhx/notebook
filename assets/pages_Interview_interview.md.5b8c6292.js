import{_ as e,j as a,k as t,V as o}from"./chunks/framework.5dd7d4b8.js";const b=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"pages/Interview/interview.md","filePath":"pages/Interview/interview.md","lastUpdated":1707022210000}'),i={name:"pages/Interview/interview.md"},r=o('<h3 id="问题-margin-塌陷问题如何解决" tabindex="-1">问题：Margin 塌陷问题如何解决？ <a class="header-anchor" href="#问题-margin-塌陷问题如何解决" aria-label="Permalink to &quot;问题：Margin 塌陷问题如何解决？&quot;">​</a></h3><h4 id="原因" tabindex="-1">原因 <a class="header-anchor" href="#原因" aria-label="Permalink to &quot;原因&quot;">​</a></h4><h4 id="解决方法" tabindex="-1">解决方法 <a class="header-anchor" href="#解决方法" aria-label="Permalink to &quot;解决方法&quot;">​</a></h4><p>1 触发bfc（块级格式化格式上下文）</p><ul><li>脱离文档流 <ul><li>overflow 部位none</li><li>定位</li><li>float</li></ul></li></ul><h3 id="空窗期" tabindex="-1">空窗期？ <a class="header-anchor" href="#空窗期" aria-label="Permalink to &quot;空窗期？&quot;">​</a></h3><h4 id="解决方法-1" tabindex="-1">解决方法 <a class="header-anchor" href="#解决方法-1" aria-label="Permalink to &quot;解决方法&quot;">​</a></h4><ul><li>帮朋友写项目</li><li>关于什么的项目</li><li>做了什么</li><li>现在到了什么阶段</li></ul><h3 id="vue3-里ref-和-reactive-的区别" tabindex="-1">vue3 里ref 和 reactive 的区别？ <a class="header-anchor" href="#vue3-里ref-和-reactive-的区别" aria-label="Permalink to &quot;vue3 里ref 和 reactive 的区别？&quot;">​</a></h3><p>如果是引用类型 ref 内部使用的是 reactive</p><h3 id="vue3-的diff算法" tabindex="-1">vue3 的diff算法 <a class="header-anchor" href="#vue3-的diff算法" aria-label="Permalink to &quot;vue3 的diff算法&quot;">​</a></h3><h3 id="防抖节流-概念" tabindex="-1">防抖节流 概念 <a class="header-anchor" href="#防抖节流-概念" aria-label="Permalink to &quot;防抖节流 概念&quot;">​</a></h3><p>防抖 一定时间触发只执行最后一次 节流 一定时间 短信验证码 一段时间只执行一次</p><h3 id="什么是websocket" tabindex="-1">什么是websocket <a class="header-anchor" href="#什么是websocket" aria-label="Permalink to &quot;什么是websocket&quot;">​</a></h3><p>H5 提供的持久连接（长轮询）； http1.0 http1.1都是不支持的 持久连接的； http1.1的 keepalive 是将多个 http 请求合并为一个；</p><p>websocket 是基于 http协议的 http1.0 只允许一个request 返回一个response； http1.1 允许客户端 发出多个request 服务器可以同时返回多个response 关系是一一对应的；</p><h3 id="http-2-0" tabindex="-1">http 2.0 <a class="header-anchor" href="#http-2-0" aria-label="Permalink to &quot;http 2.0&quot;">​</a></h3><p>https 是基于ssl加密的http 协议 ； （ssl 安全通信协议 加密方式 有公钥 加密 私钥加密）；</p><p>提升的访问速度（对于 http1.0而言 请求时间更少 请求速度更快） 多路复用（在一个物理信道上同传输多个信号，发送多个请求 提升了信道的利用率 降低传输成本 【当然引发 工艺成本？】） 改善了（同一时间 同一域名请求数量 超过会被阻塞） 二进制分帧 （将传输信息分割陈更小的信息单元（信息和帧） 并对他们进行二进制分帧 同时为了兼容 http1.x 将header封装到了Headers中 request body封装到了Data帧中）</p><h3 id="请求状态码" tabindex="-1">请求状态码？ <a class="header-anchor" href="#请求状态码" aria-label="Permalink to &quot;请求状态码？&quot;">​</a></h3><h3 id="fetch-发送两次请求" tabindex="-1">fetch 发送两次请求？ <a class="header-anchor" href="#fetch-发送两次请求" aria-label="Permalink to &quot;fetch 发送两次请求？&quot;">​</a></h3><p>options 请求 预检请求 服务器是否支持该请求类型 第二次发送真正的请求</p><h3 id="cookies-sessionstorage-localstorage-区别联系" tabindex="-1">cookies sessionStorage localStorage 区别联系？ <a class="header-anchor" href="#cookies-sessionstorage-localstorage-区别联系" aria-label="Permalink to &quot;cookies sessionStorage localStorage 区别联系？&quot;">​</a></h3><p>sessionStorage 生命周期为 关闭浏览器窗口 localStorage 生命周期为 永久，除非手动删除 cookies 生命周期为 设置过期时间</p><h3 id="web-worker" tabindex="-1">web worker ? <a class="header-anchor" href="#web-worker" aria-label="Permalink to &quot;web worker ?&quot;">​</a></h3><p>执行指定的 URl 脚本 脚本必须遵守 同源策略 可以用来执行复杂的脚本 不会阻塞主线程</p><h3 id="html语义化标签的理解" tabindex="-1">HTML语义化标签的理解 <a class="header-anchor" href="#html语义化标签的理解" aria-label="Permalink to &quot;HTML语义化标签的理解&quot;">​</a></h3><p>Html5 新增的语义化标签 结构良好 便于阅读 有利于SEO 利于开发和维护</p><h3 id="iframe-是什么-优缺点" tabindex="-1">iframe 是什么 优缺点？ <a class="header-anchor" href="#iframe-是什么-优缺点" aria-label="Permalink to &quot;iframe 是什么 优缺点？&quot;">​</a></h3><p>iframe 是内联框架 嵌入网页 的解决方案 是移动端的解决方案</p><p>缺点：</p><ol><li>搜索引擎 无法解析 无法爬取</li><li>页面加载速度慢 onload 事件无法触发</li><li>同源策略（？）</li></ol><h3 id="doctype-作用" tabindex="-1">Doctype 作用？ <a class="header-anchor" href="#doctype-作用" aria-label="Permalink to &quot;Doctype 作用？&quot;">​</a></h3><p>文档的声明告诉浏览器 当前文件采用的什么标准 严格模式 浏览器必须支持HTML5规范 才能被正常渲染 混杂模式 是为了兼容旧版本的浏览器 现代的浏览器都是支持HTML5的</p><h3 id="cookies-防止xss工具" tabindex="-1">cookies 防止XSS工具？ <a class="header-anchor" href="#cookies-防止xss工具" aria-label="Permalink to &quot;cookies 防止XSS工具？&quot;">​</a></h3><p>XSS 是一种网站的安全漏洞攻击，通过代码注入网页 其他用户受到不可控影响的攻击方式 主要分为反射形 存储形和 DOM-based 通过Xss 来获取用户的敏感信息 cookies session tokens 或者以其他方式欺诈用户 甚至完全控制浏览器</p><h3 id="restful-是什么" tabindex="-1">RESTFUL 是什么？ <a class="header-anchor" href="#restful-是什么" aria-label="Permalink to &quot;RESTFUL 是什么？&quot;">​</a></h3><p>RESTFUL 是一种通过HTTP协议传输数据，通过URL来标识资源的位置和状态</p><h3 id="click-ios-会有300ms-延迟" tabindex="-1">click ios 会有300ms 延迟？ <a class="header-anchor" href="#click-ios-会有300ms-延迟" aria-label="Permalink to &quot;click ios 会有300ms 延迟？&quot;">​</a></h3><ol><li>禁用掉缩放 viewport user-scaleable=no</li><li>检测到touchend事件后 立即模拟触发 click事件 阻止 touchend 事件的默认行为</li></ol><h3 id="强缓存-协商缓存" tabindex="-1">强缓存 协商缓存？ <a class="header-anchor" href="#强缓存-协商缓存" aria-label="Permalink to &quot;强缓存 协商缓存？&quot;">​</a></h3>',41),l=[r];function s(h,n,c,d,p,u){return a(),t("div",null,l)}const k=e(i,[["render",s]]);export{b as __pageData,k as default};
